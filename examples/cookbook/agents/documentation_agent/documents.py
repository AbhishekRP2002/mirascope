retrieved_mirascope_docs = [
    {
        "id": 0,
        "text": "Best Practices\n\n- Provider Flexibility: Design functions to be provider-agnostic, allowing easy switching between different LLM providers for comparison or fallback strategies.\n- Provider-Specific Prompts: Tailor prompts to leverage unique features of specific providers when needed, using provider-specific `call` decorators. For example, Anthropic is known to handle prompts with XML particularly well.\n- Error Handling: Implement robust error handling to manage API failures, timeouts, or content policy violations, ensuring your application's resilience. Check out our documentation on using Tenacity for how to easily add retries to your error handling logic.\n- Streaming for Long Tasks: Utilize streaming for long-running tasks or when providing real-time updates to users, improving the user experience. Check out the `Streams` documentation for more details.\n- Modular Function Design: Break down complex tasks into smaller, modular functions that can be chained together, enhancing reusability and maintainability. Check out the `Chaining` documentation for more details.\n- Custom Clients: Leverage custom clients when working with self-hosted models or specific API configurations, allowing for greater flexibility in deployment scenarios. For example, you can use open-source models by serving OpenAI compatible endpoints (e.g. with `vLLM`, `Ollama`, etc).\n- Structured Outputs: Use `response_models` to ensure consistency and type safety when you need structured data from your LLM calls. Check out the `Response Models` documentation for more details.\n- Parameterized Calls: Take advantage of `call_params` to customoize model behavior without changing your core function logic.\n\nMastering the `call` decorator is the next step towards building robust LLM applications with Mirascope that are flexible, efficient, and adaptable to various providers and use cases.",
        "semantic_score": 0.8409705413315509,
    },
    {
        "id": 1,
        "text": 'Calls\n\n??? api "API Documentation"\n\n    `mirascope.core.anthropic.call`\n\n    `mirascope.core.cohere.call`\n\n    `mirascope.core.gemini.call`\n\n    `mirascope.core.groq.call`\n\n    `mirascope.core.litellm.call`\n\n    `mirascope.core.mistral.call`\n\n    `mirascope.core.openai.call`\n\nThe `call` decorator is a core feature of the Mirascope library, designed to simplify and streamline interactions with various Large Language Model (LLM) providers. This powerful tool allows you to transform Python functions into LLM API calls with minimal boilerplate code while providing type safety and consistency across different providers.\n\nThe primary purpose of the call decorator is to:\n\n- Abstract away the complexities of different LLM APIs\n- Provide a unified interface for making LLM calls\n- Enable easy switching between different LLM providers\n- Enhance code readability and maintainability\n\nBy using the `call` decorator, you can focus on designing your prompts and handling the LLM responses, rather than dealing with the intricacies of each provider\'s API.',
        "semantic_score": 0.8382667131947247,
    },
    {
        "id": 2,
        "text": 'Error Handling\n\nWhen making LLM calls, it\'s important to handle potential errors. Mirascope preserves the original error messages from providers, allowing you to catch and handle them appropriately:\n\n```python\nfrom openai import OpenAIError\nfrom mirascope.core import openai, prompt_template\n\n\n@openai.call(model="gpt-4o-mini")\n@prompt_template("Recommend a {genre} book")\ndef recommend_book(genre: str):\n    ...\n\n\ntry:\n    response = recommend_book("fantasy")\n    print(response.content)\nexcept OpenAIError as e:\n    print(f"Error: {str(e)}")\n```\n\nBy catching provider-specific errors, you can implement appropriate error handling and fallback strategies in your application. You can of course always catch the base `Exception` instead of provider-specific exceptions.',
        "semantic_score": 0.797588859470311,
    },
    {
        "id": 3,
        "text": 'Supported Providers\n\nMirascope\'s call decorator supports multiple LLM providers, allowing you to easily switch between different models or compare outputs. Each provider has its own module within the Mirascope library. We currently support the following providers:\n\n- OpenAI (and any provider with an OpenAI compatible endpoint)\n- Anthropic\n- Mistral\n- Gemini\n- Groq\n- Cohere\n- LiteLLM (for multi-provider support)\n\nTo use a specific provider, simply use the `call` decorator from the corresponding provider\'s module. Here\'s an example of how to use multiple different providers with the same function:\n\n```python\nfrom mirascope.core import anthropic, mistral, openai, prompt_template\n\n\n@prompt_template("Recommend a {genre} book")\ndef recommend_book(genre: str):\n    ...\n\n\nopenai_recommendation = openai.call("gpt-4o-mini")(recommend_book)("fantasy")\nprint("OpenAI recommendation:", openai_recommendation.content)\n\nanthropic_recommendation = anthropic.call("claude-3-5-sonnet-20240620")(recommend_book)("fantasy")\nprint("Anthropic recommendation:", anthropic_recommendation.content)\n\nmistral_recommendation = mistral.call("mistral-large-latest")(recommend_book)("fantasy")\nprint("Mistral recommendation:", mistral_recommendation.content)\n```\n\nThis flexibility allows you to compare outputs from different providers or switch between them based on your specific needs without changing your core logic.\n\n!!! note "Import Structure"\n\n    We\'ve shown importing each provider\'s module and using their respective `call` decorators. If preferred, you can instead directly import the non-aliased decorator (e.g. `from mirascope.core.openai import openai_call`).',
        "semantic_score": 0.7946593277703506,
    },
    {
        "id": 4,
        "text": 'Handling Responses\n\n??? api "API Documentation"\n\n    `mirascope.core.anthropic.call_response`\n\n    `mirascope.core.cohere.call_response`\n\n    `mirascope.core.gemini.call_response`\n\n    `mirascope.core.groq.call_response`\n\n    `mirascope.core.mistral.call_response`\n\n    `mirascope.core.openai.call_response`\n\nWhen you make a call to an LLM using Mirascope\'s `call` decorator, the response is wrapped in a provider-specific `BaseCallResponse` object (e.g. `OpenAICallResponse`). This object provides a consistent interface for accessing the response data across different providers while still offering access to provider-specific details.',
        "semantic_score": 0.7904046792058725,
    },
    {
        "id": 5,
        "text": "Type Safety and Proper Hints\n\nOne of the primary benefits of Mirascope is the enhanced type safety and proper type hints provided by the `call` decorator. This feature ensures that your IDE and type checker can accurately infer the return types of your LLM calls based on the parameters you've set.\n\nFor example:\n\n- When using a basic call, the output will be properly typed as the provider-specific call response.\n- When you set a `response_model`, the output will be properly typed as the `ResponseModelT` type of the `response_model` you passed in.\n- When streaming is enabled, the return type will reflect the stream type.\n- If you use an `output_parser`, the return type will match the parser's output type.\n\nThis type safety extends across all the different settings of the `call` decorator, providing a robust development experience and helping to catch potential type-related errors early in the development process.\n\n!calls-type-hint\n\nIn this example, your IDE will provide proper autocompletion and type checking for `recommendation.content` and `recommendation.response`, enhancing code reliability and developer productivity.",
        "semantic_score": 0.7874003044289272,
    },
    {
        "id": 6,
        "text": 'Provider-Specific Parameters\n\n??? api "API Documentation"\n\n    `mirascope.core.anthropic.call_params`\n\n    `mirascope.core.cohere.call_params`\n\n    `mirascope.core.gemini.call_params`\n\n    `mirascope.core.groq.call_params`\n\n    `mirascope.core.mistral.call_params`\n\n    `mirascope.core.openai.call_params`\n\nWhile Mirascope provides a consistent interface across different LLM providers, each provider has its own set of specific parameters that can be used to further configure the behavior of the model. These parameters are passed to the `call` decorator through the `call_params` argument.\n\nFor all providers, we have only included additional call parameters that are not already covered as shared arguments to the `call` decorator (e.g. `model`). We have also opted to exclude currently deprecated parameters entirely. However, since `call_params` is just a `TypedDict`, you can always include any additional keys at the expense of type errors (and potentially unknown behavior).\n\nHere is an example using custom OpenAI call parameters to change the temperature:\n\n```python\nfrom mirascope.core import openai, prompt_template\n\n\n@openai.call("gpt-4o-mini", call_params={"temperature": 0.7})\n@prompt_template("Recommend a {genre} book")\ndef recommend_book(genre: str):\n    ...\n\n\nresponse = recommend_book("fantasy")\nprint(response.content)\n```',
        "semantic_score": 0.7857430550689157,
    },
    {
        "id": 7,
        "text": 'Custom Client\n\nMirascope allows you to use custom clients when making calls to LLM providers. This feature is particularly useful when you need to use specific client configurations, handle authentication in a custom way, or work with self-hosted models.\n\nTo use a custom client, you can pass it to the `call` decorator using the `client` parameter. Here\'s an example using a custom OpenAI client:\n\n```python\nfrom openai import OpenAI\nfrom mirascope.core import openai, prompt_template\n\n# Create a custom OpenAI client\ncustom_client = OpenAI(\n    api_key="your-api-key",\n    organization="your-organization-id",\n    base_url="https://your-custom-endpoint.com/v1"\n)\n\n\n@openai.call(model="gpt-4o-mini", client=custom_client)\n@prompt_template("Recommend a {genre} book")\ndef recommend_book(genre: str):\n    ...\n\n\nresponse = recommend_book("fantasy")\nprint(response.content)\n```\n\nAny custom client is supported so long as it has the same API as the original base client.',
        "semantic_score": 0.7806925592283367,
    },
    {
        "id": 8,
        "text": 'Provider-Specific Response Details\n\nWhile Mirascope provides a consistent interface, you can also always access the full, provider-specific response object if needed. This is available through the `response` property of the `BaseCallResponse` object.\n\n```python\n# Accessing OpenAI-specific chat completion details\ncompletion = response.response\nprint(f"Content: {completion.choices[0].message.content}")\n```\n\n!!! note "Reasoning For Provider-Specific `BaseCallResponse` Objects"\n\n    The reason that we have provider-specific response objects (e.g. `OpenAICallResponse`) is to provide proper type hints and safety when accessing the original response.',
        "semantic_score": 0.7420925196155702,
    },
    {
        "id": 9,
        "text": "Common Parameters Across Providers\n\nWhile each LLM provider has its own specific parameters, there are several common parameters that you'll find across all providers when using the `call` decorator. These parameters allow you to control various aspects of the LLM call:\n\n- `model`: The only required parameter for all providers, which may be passed in as a standard argument (whereas all others are optional and must be provided as keyword arguments). It specifies which language model to use for the generation. Each provider has its own set of available models.\n- `stream`: A boolean that determines whether the response should be streamed or returned as a complete response. We cover this in more detail in the `Streams` documentation.\n- `tools`: A list of tools that the model may request to use in its response. We cover this in more detail in the `Tools` documentation.\n- `response_model`: A Pydantic `BaseModel` type that defines how to structure the response. We cover this in more detail in the `Response Models` documentation.\n- `output_parser`: A function for parsing the response output. We cover this in more detail in the `Output Parsers` documentation.\n- `json_mode`: A boolean that deterines whether to use JSON mode or not. We cover this in more detail in the `JSON Mode` documentation.\n- `client`: A custom client to use when making the call to the LLM. We cover this in more detail in the `Custom Client` section below.\n- `call_params`: The provider-specific parameters to use when making the call to that provider's API. We cover this in more detail in the `Provider-Specific Parameters` section below.\n\nThese common parameters provide a consistent way to control the behavior of LLM calls across different providers. Keep in mind that while these parameters are widely supported, there might be slight variations in how they're implemented or their exact effects across different providers (and the documentation should cover any such differences).",
        "semantic_score": 0.7391832549380211,
    },
]

retrieve_dummy_docs = [
    {"id": 0, "document": "Bob eats burgers every day.", "score": 7},
    {"id": 1, "document": "Bob's favorite food is not pizza.", "score": 9},
    {"id": 2, "document": "I ate at In-N-Out with Bob yesterday", "score": 4},
]
